#pragma region template
/*

*/
#pragma endregion

#pragma region static, extern
/*
- 변수의 라이프 사이클을 지정해주는 키워드

▷ static
- static으로 선언된 변수는 기본값이 0으로 자동 초기화 된다.

- 전역변수에 붙는 static 
	- 현재 파일로 범위를 제한.
- 지역변수에 붙는 static 
	-함수가 종료되더라도 해당 함수 재실행시 기존 변수의 값이 살아있음.
- 클래스 멤버에 붙는 static
	- 클래스 내부에서 static으로 선언된 멤버는 해당 클래스의 모든 인스턴스에서 공유
	- 클래스의 인스턴스끼리 공통으로 사용
	- 클래스의 인스턴스가 없이도 접근이 가능함.
	- 정적 멤버 함수에서는 일반 멤버 변수를 호출 불가능

- 클래스 멤버에 붙는 static 선언방법
	- 클래스 내부에서 static을 사용하여 선언
	- 이 선언은 컴파일러한테 해당 클래스에 정적 멤버변수가 있음을 알려줌
	- 단, ::을 사용해서 외부에서 초기화를 해주어야함.


▷ extern
- 전역변수에 붙는 extern -> 진짜 전역변수. 모든 파일과 공유.
- extern 키워드는 전역변수가 외부에 있다는 것을 표시만 할 뿐이고 선언을 하지는 않는다.
*/
#pragma endregion

#pragma region 복사생성자
/*
▷ 복사 생성자
- 동일한 클래스의 객체를 복사해서 생성할때 사용하는 생성자
- 선언이 없으면 컴파일러가 알아서 생성해줌.
	- Person(const Person& other) : age(other.age) {};
- 기본 복사 생성자는 얕은 복사 
	- 포인터 사용시 같은 메모리 주소를 참조하기 때문에 문제가 발생할 수 있다.
		- 기존 객체를 소멸시킬 경우 포인터 변수가 유효하지 않은 메모리 주소를 가르키게 된다.
- 깊은 복사 생성자는 다음과 같이 구현
EX)
	MyArray2(const MyArray2& other)
	{
		this->size = other.size;
		this->data = new int[other.size];
		for (int i = 0; i < size; i++)
		{
			this->data[i] = other.data[i];
		}
	};


▷ 얕은 복사 vs 깊은 복사
1. 얕은 복사(Shallow Copy)
- 객체를 복사할 때, 해당 객체만 복사하여 새 객체를 생성한다.
- 복사된 객체의 인스턴스 변수는 원본 객체의 인스턴스 변수와 같은 메모리 주소를 참조한다.
- 따라서, 해당 메모리 주소의 값이 변경되면 원본 객체 및 복사 객체의 인스턴스 변수 값은 같이 변경된다.

2. 깊은 복사(Deep Copy)
- 객체를 복사 할 때, 해당 객체와 인스턴스 변수까지 복사하는 방식.
- 전부를 복사하여 새 주소에 담기 때문에 참조를 공유하지 않는다.
*/
#pragma endregion

#pragma region 상속
/*
▷ 상속
- 클래스간의 상속관계를 맺을때는 공통의 기능을 상위 클래스에 묶어 넣어 다른 클래스로 확장할 수 있게 하는것이 목적
- 만약 클래스들이 서로 비슷한 또는 완전히 같은 코드를 가지고 있다면 해당 코드를 상위 클래스로 묶어내는 것을 고려하는게 좋다.

▷ 사용 방법
- class Child : public Parent
- 상속시의 접근제어지시자의 경우 상속시 부모의 멤버 변수의 공개 범위에 대한 최대값을 제한한다고 생각하면 편함
- 부모 클래스의 멤버를 전부 해당 접근제어지시자로 만드는것이 아님에 주의.

▷ 상속의 생성자와 소멸자
- 상속된 클래스들의 생성자와 소멸자 호출 순서는 다음과 같다
- 부모생성자 -> 자식생성자
- 자식소멸자 -> 부모소멸자

▷ 다중상속의 문제점
- 다이아몬드 상속 문제
	- 부모가 둘 이상인 경우 같은 이름의 멤버가 존재하는 경우 충돌 발생 등 모호함이 발생
- C++에서는 지원하지만, C#이나 JAVA등 이후에 나오는 언어의 경우 불가능 하도록 변경되었음.
- 사용을 지양할것.
*/
#pragma endregion

#pragma region Is-a관계와 Has-a관계
/*
▷ Is-a관계
- 쉽게 말하면 상속관계이다. 부모클래스와 자식클래스를 구별할때 IS-A 관계를 생각하곤 하는데 
- 예를들면 사과는 과일이다.컴퓨터는 전자기기이다. 등 의 관계를 생각해보자  
- 어떤 걸 부모클래스로 둬야할지 감이 오지 않는다면, 이렇게 생각해보자 
- 사과는 과일이다는 틀리지 않지만, 과일은 사과이다? 이건 명백하게 틀린말이다. 

▷ Has-a관계
- IS-A가 카테고리를 구별하기 위해 만든다면, HAS-A 는 특정기능을 사용하고 싶을때 자주 사용한다.
- 차로 예를 들자면 차는 엔진을 가지고 있다. 즉 기능을 포함시키고 싶을때 사용 하는 것이 HAS-A 이다.
- 이런 경우 객체 내부에 변수 등을 통해 포함시켜 준다.
*/
#pragma endregion

#pragma region 헤더파일
/*
▷ 헤더파일
- 헤더파일에는 일반적으로 선언만 들어감.
- 구현이나 로직은 cpp에 작성하게 됨.
- #pragme once를 통해 반복적으로 불러오지 않도록 처리가 가능하나 표준은 아님
- ifndef를 통해 처리도 가능
EX)
	#ifndef UNIT_H
	#define UNIT_H
	class Unit {};
	#endif
*/
#pragma endregion

/*
과제1. 

*/