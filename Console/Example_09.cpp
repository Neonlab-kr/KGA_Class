#pragma region 포인터
/*
▶ 포인터란 ? 
- 포인터는 주소를 저장한다.
- 모든 데이터는 메모리상의 특정한 공간에 저장되어 있음.
- 기존에 우리가 알고 있는 변수는 데이터를 저장하지만 포인터는 메모리 공간의 주소를 저장한다.
- 포인터 변수가 주소를 저장할면 변수의 주소를 알아야함.
ㄴ 변수이름 앞에 & 연산자를 붙히면 해당 변수의 시작주소를 반환한다.
- 또한 포인터 변수가 저장하는 변수의 주소에 저장된 값을 참조하려면 *연산자를 사용한다.

& : 특정한 데이터의 메모리상의 주소값을 알 수 있다.
* : &연산자가 어떤 데이터의 주소값을 얻어내는 연산자라면 주소값에서 해당 주소값에 대응되는 데이터를 가져온다.


▷ 포인터 변수의 타입?
- 포인터 변수는 주소만 저장하는데, 타입이 왜 필요할까?	
- 포인터는 시작 주소만을 가지고 있으므로, 메모리에서 읽어들어야할 메모리의 끝을 알수가 없음!!
- 이를 해결하기 위해 타입이 필요

▷ 포인터에서의 const
- const int*는 const int형 변수를 가리킨다는 것이 아니다.
- int형 변수를 가리키는데, 가리키는 값을 상수화 하여 변경할 수 없게 한다.

- int* const는 해당 포인터의 주소값을 상수화 하는 것이다.

▷ 댕글링 포인터
- 더이상 유효하지 않은 주소를 가리키고 있는 포인터
- 동적 할당을 해제한 이후 해당 포인터에 nullptr를 할당하는 형태로 예방 가능.

*/
#pragma endregion

#pragma region 배열과 포인터
/*
▶ 배열과 포인터의 관계
- 포인터로도 배열 원소에 접근이 가능함!
- 즉, 배열의 시작부분을 가리키는 포인터를 정의하고 포인터에 1을 더하면 그 다음 원소를 가르킨다.

▷ 배열의 이름은 포인터?
- 엄밀히 따지자면 아님!
- 단, 암묵적으로 배열의 첫 요소를 가리키는 포인터로 형변환됨.
*/
#pragma endregion

#pragma region Call By Value/Reference
/*
▷ 값에 의한 전달(CallByValue)
- 함수에 인수를 전달할 때 인수의 값이 복사되어 함수의 매개변수로 전달
- 함수 내부에서 매개변수를 변경하더라도, 호출한 함수의 실제 인수는 변하지 않는다.

▷ 참조에 의한 전달(CallByReference)
- 함수 호출시 인수로 변수의 주소를 전달하는 방식
- 함수가 매개변수로 받은 참조를 통해 실제 인수의 값을 직접 수정가능
- 함수 내부에서 매개변수의 값을 변경하면 호출한 함수의 실제 인수도 변경가능
- 값을 복사하는 대신 주소를 전달. -> 메모리와 성능 효율이 좋다.

*/
#pragma endregion

#pragma region void*
/*
▶ void타입 포인터
- 자료형이 없는 포인터 변수
- 자료형에 제약을 받지 안호 어떤 자료형의 주소든 저장 가능
ㄴ 값을 참조하려면 강제 형변환이 필요하다.
*/
#pragma endregion

#pragma region 과제
/*
과제 1 : 구조체를 활용한 학생정보 출력하기.
- 학생 정보를 출력하는 함수 포함
- 학생 정보를 추가하는 함수 포함
- 함수에 매개변수를 넘길때 참조 방식으로 할것.

한줄 조사1 : 정적할당과 동적할당의 차이점.
- 메모리 영역
- 할당 시기
- 할당 해제(메모리 누수)

C -> malloc, free
//int* ptr = (int*)malloc(sizeof(int)*10); //int 10개의 메모리 공간 할당
free ptr;


C++ -> new, delete
//int* ptr = new int(10);//int형 변수 하나를 동적 할당하고 10으로 초기화
//int* array = new int[5]; //int 5개의 메모리 공간 할당

delete ptr;
delete array

한줄 조사2 : 클래스란 무엇인가

한줄 조사의 경우 발표 준비를 해올것.
*/
#pragma endregion